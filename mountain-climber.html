<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Mountain Climber - Epic Truck Adventure!</title>
    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Nunito:wght@700;800;900&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html {
            overflow: hidden;
        }

        body {
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }

        /* UI Elements */
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }

        .home-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            border: 3px solid #ffd93d;
            color: #2d3436;
            padding: 10px 18px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 700;
            text-decoration: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            pointer-events: all;
        }

        .home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .stats-panel {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .stat-item {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            padding: 10px 16px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            font-weight: 800;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        }

        .stat-item .icon {
            font-size: clamp(1.1rem, 3vw, 1.4rem);
        }

        .stat-item .value {
            color: #e17055;
        }

        /* Speed meter */
        .speed-meter {
            position: fixed;
            left: 20px;
            bottom: 120px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            padding: 15px;
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .speed-value {
            font-family: 'Bubblegum Sans', cursive;
            font-size: clamp(1.5rem, 4vw, 2rem);
            color: #55efc4;
            text-shadow: 0 0 10px rgba(85, 239, 196, 0.5);
        }

        .speed-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 700;
        }

        .speed-bar {
            width: 60px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .speed-fill {
            height: 100%;
            background: linear-gradient(90deg, #55efc4, #00b894);
            border-radius: 4px;
            transition: width 0.1s;
        }

        /* Boost meter */
        .boost-meter {
            position: fixed;
            left: 20px;
            bottom: 220px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            padding: 12px;
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .boost-icon {
            font-size: 1.5rem;
        }

        .boost-bar {
            width: 20px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .boost-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #ff6b6b, #feca57, #ff9ff3);
            border-radius: 10px;
            transition: height 0.2s;
        }

        /* Trick display */
        .trick-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 200;
        }

        .trick-text {
            font-family: 'Bubblegum Sans', cursive;
            font-size: clamp(2rem, 8vw, 4rem);
            color: #ffd700;
            text-shadow: 0 4px 0 rgba(0, 0, 0, 0.3), 0 0 40px rgba(255, 215, 0, 0.6);
            animation: trickPop 1s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes trickPop {
            0% { transform: scale(0) rotate(-20deg); opacity: 1; }
            30% { transform: scale(1.3) rotate(10deg); opacity: 1; }
            100% { transform: scale(1) rotate(0) translateY(-30px); opacity: 0; }
        }

        /* Combo display */
        .combo-display {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 150;
            text-align: center;
        }

        .combo-text {
            font-family: 'Bubblegum Sans', cursive;
            font-size: clamp(1.2rem, 4vw, 2rem);
            color: #ff6b6b;
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
        }

        .combo-multiplier {
            font-size: clamp(2rem, 6vw, 3rem);
            color: #feca57;
            text-shadow: 0 3px 0 rgba(0, 0, 0, 0.2), 0 0 20px rgba(254, 202, 87, 0.5);
        }

        /* Height indicator */
        .height-indicator {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            padding: 15px 12px;
            border-radius: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .height-bar {
            width: 20px;
            height: 150px;
            background: #dfe6e9;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .height-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #a29bfe, #fd79a8, #fdcb6e, #55efc4);
            border-radius: 10px;
            transition: height 0.3s ease;
        }

        .height-label {
            font-size: 0.7rem;
            font-weight: 800;
            color: #636e72;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .height-value {
            font-size: 0.8rem;
            font-weight: 800;
            color: #e17055;
        }

        /* Zone indicator */
        .zone-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 800;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Play button */
        .play-button {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #00b894, #00a085);
            color: white;
            border: none;
            padding: 22px 50px;
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            border-radius: 60px;
            cursor: pointer;
            font-family: 'Bubblegum Sans', cursive;
            box-shadow: 0 8px 0 #007a63, 0 15px 40px rgba(0, 184, 148, 0.4);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-touch-callout: none;
        }

        .play-button:active, .play-button.pressed {
            transform: translateX(-50%) translateY(5px);
            box-shadow: 0 3px 0 #007a63, 0 8px 20px rgba(0, 184, 148, 0.4);
        }

        .play-button .icon {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            animation: truckBounce 0.5s ease-in-out infinite;
        }

        @keyframes truckBounce {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-4px) rotate(3deg); }
        }

        /* Boost button */
        .boost-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: linear-gradient(180deg, #ff6b6b, #ee5a5a);
            border: none;
            border-radius: 50%;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 0 6px 0 #c44545, 0 10px 30px rgba(238, 90, 90, 0.4);
            z-index: 100;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .boost-button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #c44545;
        }

        .boost-button.empty {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Instruction */
        .instruction {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 25px;
            border-radius: 25px;
            font-size: clamp(0.85rem, 2.5vw, 1.1rem);
            font-weight: 700;
            color: #2d3436;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 100;
            text-align: center;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-8px); }
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            pointer-events: all;
        }

        .sound-toggle.muted {
            opacity: 0.5;
        }

        /* Customize panel */
        .customize-panel {
            position: fixed;
            top: 80px;
            right: 80px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .customize-label {
            font-size: 0.75rem;
            font-weight: 800;
            color: #636e72;
            text-align: center;
        }

        .color-options, .hat-options {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-btn, .hat-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .color-btn:hover, .hat-btn:hover {
            transform: scale(1.15);
        }

        .color-btn.active, .hat-btn.active {
            border-color: #2d3436;
        }

        .color-btn.locked, .hat-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }

        /* Sparkle effects */
        .sparkle {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 200;
        }

        .sparkle::before, .sparkle::after {
            content: '';
            position: absolute;
            background: #ffd700;
            border-radius: 3px;
        }

        .sparkle::before {
            width: 100%;
            height: 6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .sparkle::after {
            width: 6px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .sparkle {
            animation: sparkleAnim 0.6s ease-out forwards;
        }

        @keyframes sparkleAnim {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            100% { transform: scale(2.5) rotate(45deg); opacity: 0; }
        }

        .collect-text {
            position: absolute;
            font-family: 'Bubblegum Sans', cursive;
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            color: #ffd700;
            text-shadow: 0 3px 0 rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 215, 0, 0.6);
            pointer-events: none;
            z-index: 200;
            animation: floatUp 1.2s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.2); opacity: 0; }
        }

        /* Unlock notification */
        .unlock-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #fff, #f8f9fa);
            padding: 25px 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 500;
            animation: unlockPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes unlockPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            70% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .unlock-notification h2 {
            font-family: 'Bubblegum Sans', cursive;
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: #e17055;
            margin-bottom: 8px;
        }

        .unlock-notification .unlock-item {
            font-size: clamp(2.5rem, 8vw, 4rem);
            margin: 10px 0;
            animation: unlockBounce 0.5s ease infinite;
        }

        @keyframes unlockBounce {
            0%, 100% { transform: scale(1) rotate(-5deg); }
            50% { transform: scale(1.1) rotate(5deg); }
        }

        .unlock-notification p {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            color: #636e72;
            font-weight: 700;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .speed-meter {
                left: 10px;
                bottom: 110px;
                padding: 10px;
            }

            .boost-meter {
                left: 10px;
                bottom: 200px;
                padding: 8px;
            }

            .boost-bar {
                height: 60px;
            }

            .boost-button {
                width: 65px;
                height: 65px;
                right: 20px;
                font-size: 1.5rem;
            }

            .customize-panel {
                top: auto;
                bottom: 130px;
                right: 10px;
                padding: 8px;
            }

            .zone-indicator {
                top: 70px;
                right: 10px;
                font-size: 0.75rem;
            }

            .height-indicator {
                right: 10px;
                padding: 10px 8px;
            }

            .height-bar {
                height: 100px;
            }

            .play-button {
                padding: 18px 40px;
                bottom: 25px;
            }

            .instruction {
                bottom: 105px;
                padding: 10px 18px;
            }
        }

        @media (max-height: 600px) {
            .height-indicator {
                display: none;
            }

            .boost-meter {
                bottom: 120px;
            }

            .customize-panel {
                flex-direction: row;
                top: 70px;
                right: 80px;
                bottom: auto;
            }
        }
    </style>
</head>

<body>
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <!-- UI -->
        <div class="game-ui">
            <div></div>
            <div class="stats-panel">
                <div class="stat-item">
                    <span class="icon">‚≠ê</span>
                    <span class="value" id="starCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="icon">üî•</span>
                    <span class="value" id="trickScore">0</span>
                </div>
            </div>
        </div>

        <a href="index.html" class="home-btn">üè† Home</a>
        <button class="sound-toggle" id="soundToggle">üîä</button>

        <!-- Speed meter -->
        <div class="speed-meter">
            <div class="speed-value" id="speedValue">0</div>
            <div class="speed-label">MPH</div>
            <div class="speed-bar">
                <div class="speed-fill" id="speedFill" style="width: 0%"></div>
            </div>
        </div>

        <!-- Boost meter -->
        <div class="boost-meter">
            <div class="boost-icon">üöÄ</div>
            <div class="boost-bar">
                <div class="boost-fill" id="boostFill" style="height: 100%"></div>
            </div>
        </div>

        <!-- Height indicator -->
        <div class="height-indicator">
            <div class="height-value" id="heightValue">0m</div>
            <div class="height-bar">
                <div class="height-fill" id="heightFill" style="height: 0%"></div>
            </div>
            <div class="height-label">HEIGHT</div>
        </div>

        <!-- Zone indicator -->
        <div class="zone-indicator" id="zoneIndicator">
            <span>üåø</span>
            <span>Meadow Zone</span>
        </div>

        <!-- Customize panel -->
        <div class="customize-panel" id="customizePanel">
            <div class="customize-label">Color</div>
            <div class="color-options" id="colorOptions"></div>
            <div class="customize-label">Hat</div>
            <div class="hat-options" id="hatOptions"></div>
        </div>

        <!-- Combo display -->
        <div class="combo-display hidden" id="comboDisplay">
            <div class="combo-text">COMBO</div>
            <div class="combo-multiplier" id="comboMultiplier">x2</div>
        </div>

        <!-- Trick display -->
        <div class="trick-display" id="trickDisplay"></div>

        <!-- Instruction -->
        <div class="instruction" id="instruction">
            HOLD to drive! Hit ramps for FLIPS! Tap üöÄ for BOOST!
        </div>

        <!-- Play button -->
        <button class="play-button" id="playButton">
            <span class="icon">üöö</span>
            <span>HOLD TO GO!</span>
        </button>

        <!-- Boost button -->
        <button class="boost-button" id="boostButton">üöÄ</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Audio
        let audioCtx = null;
        let soundEnabled = true;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            switch (type) {
                case 'ding':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(1100, audioCtx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(1320, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'boost':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'flip':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'land':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'launch':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.25);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'engine':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(60 + Math.random() * 30, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.08);
                    break;
                case 'unlock':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.12);
                    osc.frequency.setValueAtTime(784, audioCtx.currentTime + 0.24);
                    osc.frequency.setValueAtTime(1047, audioCtx.currentTime + 0.36);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.6);
                    break;
                case 'combo':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(900, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;
            }
        }

        document.getElementById('soundToggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundToggle');
            btn.textContent = soundEnabled ? 'üîä' : 'üîá';
            btn.classList.toggle('muted', !soundEnabled);
        });

        // Game state
        let isPlaying = false;
        let isBoosting = false;
        let truckX = 100;
        let truckY = 0;
        let truckVelocityX = 0;
        let truckVelocityY = 0;
        let cameraX = 0;
        let cameraY = 0;
        let truckAngle = 0;
        let truckAngularVelocity = 0;
        let totalRotation = 0;
        let isInAir = false;
        let airTime = 0;
        let boostFuel = 100;
        let trickScore = 0;
        let comboCount = 0;
        let comboTimer = 0;
        let lastFlipCount = 0;

        // Suspension
        let frontSuspension = 0;
        let rearSuspension = 0;

        // Particles
        const dustParticles = [];
        const boostParticles = [];

        // Collections
        let stars = 0;

        // Customization
        let currentColor = '#e74c3c';
        let currentHat = '';
        const unlockedColors = ['#e74c3c'];
        const unlockedHats = [''];

        const allColors = [
            { color: '#e74c3c', name: 'Red', height: 0 },
            { color: '#3498db', name: 'Blue', height: 100 },
            { color: '#2ecc71', name: 'Green', height: 200 },
            { color: '#9b59b6', name: 'Purple', height: 400 },
            { color: '#f39c12', name: 'Orange', height: 600 },
            { color: '#1abc9c', name: 'Teal', height: 800 },
            { color: '#e91e63', name: 'Pink', height: 1000 },
            { color: '#ffd700', name: 'Gold', height: 1500 }
        ];

        const allHats = [
            { emoji: '', name: 'None', height: 0 },
            { emoji: 'üé©', name: 'Top Hat', height: 150 },
            { emoji: 'üëë', name: 'Crown', height: 300 },
            { emoji: 'üéÄ', name: 'Bow', height: 500 },
            { emoji: 'üå∏', name: 'Flower', height: 700 },
            { emoji: '‚≠ê', name: 'Star', height: 900 },
            { emoji: 'ü¶ã', name: 'Butterfly', height: 1200 },
            { emoji: 'üåà', name: 'Rainbow', height: 2000 }
        ];

        // Terrain and scenery
        const terrainPoints = [];
        const collectibles = [];
        const sceneryItems = [];
        const backgroundMountains = [];
        const clouds = [];
        const birds = [];

        // Zone definitions
        const zones = [
            { name: 'Meadow', icon: 'üåø', minHeight: 0, grassColor: '#55efc4', groundColor: '#00b894', skyTop: '#74b9ff', skyBottom: '#a8e6cf' },
            { name: 'Forest', icon: 'üå≤', minHeight: 300, grassColor: '#2ecc71', groundColor: '#27ae60', skyTop: '#5f9ea0', skyBottom: '#90ee90' },
            { name: 'Rocky', icon: 'ü™®', minHeight: 600, grassColor: '#95a5a6', groundColor: '#7f8c8d', skyTop: '#778899', skyBottom: '#b0c4de' },
            { name: 'Snow', icon: '‚ùÑÔ∏è', minHeight: 1000, grassColor: '#ecf0f1', groundColor: '#bdc3c7', skyTop: '#87ceeb', skyBottom: '#e0ffff' },
            { name: 'Peak', icon: '‚õ∞Ô∏è', minHeight: 1500, grassColor: '#fff', groundColor: '#dfe6e9', skyTop: '#4a69bd', skyBottom: '#6a89cc' }
        ];

        function getCurrentZone() {
            const height = canvas.height - truckY;
            for (let i = zones.length - 1; i >= 0; i--) {
                if (height >= zones[i].minHeight) return zones[i];
            }
            return zones[0];
        }

        function generateTerrain() {
            terrainPoints.length = 0;
            collectibles.length = 0;
            sceneryItems.length = 0;

            let x = 0;
            let y = canvas.height - 150;
            const totalLength = 30000;

            while (x < totalLength) {
                terrainPoints.push({ x, y });

                const segmentType = Math.random();
                let segmentLength, yChange;

                if (segmentType < 0.2) {
                    // BIG JUMP RAMP
                    segmentLength = 70;
                    yChange = -(100 + Math.random() * 80);
                    terrainPoints.push({ x: x + segmentLength, y: y + yChange });
                    x += segmentLength;
                    y = Math.max(100, y + yChange);
                    terrainPoints.push({ x: x + 50, y: y });
                    x += 50;
                    terrainPoints.push({ x: x + 40, y: y + 30 });
                    x += 40;
                    segmentLength = 180;
                    yChange = 70;

                    // Collectibles in air
                    for (let i = 0; i < 4; i++) {
                        collectibles.push({
                            x: x + 30 + i * 45,
                            y: y - 100 - Math.random() * 80,
                            type: i === 2 ? 'star' : 'fuel',
                            collected: false,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                    }
                } else if (segmentType < 0.35) {
                    // MEGA RAMP
                    segmentLength = 200 + Math.random() * 100;
                    yChange = -(120 + Math.random() * 60);
                    const steps = 5;
                    for (let i = 1; i <= steps; i++) {
                        const progress = i / steps;
                        const curveY = y + yChange * Math.pow(progress, 0.6);
                        terrainPoints.push({ x: x + segmentLength * progress, y: curveY });
                    }
                    x += segmentLength;
                    y = Math.max(80, y + yChange);
                    terrainPoints.push({ x: x + 60, y: y });
                    x += 60;
                    segmentLength = 220;
                    yChange = 100;

                    collectibles.push({
                        x: x,
                        y: y - 120,
                        type: 'star',
                        collected: false,
                        bobOffset: 0
                    });
                } else if (segmentType < 0.5) {
                    // LOOP-DE-LOOP hills
                    for (let bump = 0; bump < 4; bump++) {
                        const bumpWidth = 60 + Math.random() * 40;
                        const bumpHeight = 50 + Math.random() * 40;
                        terrainPoints.push({ x: x + bumpWidth * 0.5, y: y - bumpHeight });
                        terrainPoints.push({ x: x + bumpWidth, y: y });
                        x += bumpWidth;

                        if (Math.random() < 0.5) {
                            collectibles.push({
                                x: x - bumpWidth * 0.5,
                                y: y - bumpHeight - 60,
                                type: Math.random() < 0.3 ? 'star' : 'fuel',
                                collected: false,
                                bobOffset: Math.random() * Math.PI * 2
                            });
                        }
                    }
                    segmentLength = 100;
                    yChange = -(20 + Math.random() * 30);
                } else if (segmentType < 0.65) {
                    // STUNT RAMP
                    segmentLength = 50;
                    yChange = -(80 + Math.random() * 50);
                    terrainPoints.push({ x: x + segmentLength, y: y + yChange });
                    x += segmentLength;
                    y = Math.max(100, y + yChange);
                    terrainPoints.push({ x: x + 20, y: y });
                    x += 20;
                    segmentLength = 150;
                    yChange = 60;

                    collectibles.push({
                        x: x + 70,
                        y: y - 50,
                        type: 'star',
                        collected: false,
                        bobOffset: 0
                    });
                } else if (segmentType < 0.8) {
                    // Gentle slope
                    segmentLength = 120 + Math.random() * 100;
                    yChange = -(20 + Math.random() * 35);

                    if (Math.random() < 0.4) {
                        collectibles.push({
                            x: x + segmentLength / 2,
                            y: y - 70,
                            type: Math.random() < 0.5 ? 'star' : 'fuel',
                            collected: false,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                    }
                } else {
                    // Flat
                    segmentLength = 100 + Math.random() * 80;
                    yChange = Math.random() * 15 - 7;
                }

                x += segmentLength;
                y = Math.max(80, Math.min(canvas.height - 60, y + yChange));

                // Add scenery
                if (Math.random() < 0.4) {
                    const items = ['üå≤', 'üå≥', 'ü™®', 'üå∏', 'üåª', 'üçÑ'];
                    sceneryItems.push({
                        x: x - segmentLength / 2 + (Math.random() - 0.5) * 80,
                        type: items[Math.floor(Math.random() * items.length)],
                        scale: 0.8 + Math.random() * 0.6,
                        layer: Math.random() < 0.5 ? 'front' : 'back'
                    });
                }
            }

            terrainPoints.push({ x: totalLength, y: 80 });

            // Generate background mountains
            for (let i = 0; i < 15; i++) {
                backgroundMountains.push({
                    x: i * 800 + Math.random() * 400,
                    width: 300 + Math.random() * 400,
                    height: 150 + Math.random() * 200,
                    layer: Math.floor(Math.random() * 3)
                });
            }

            // Generate clouds
            for (let i = 0; i < 20; i++) {
                clouds.push({
                    x: i * 500 + Math.random() * 300,
                    y: 50 + Math.random() * 150,
                    width: 80 + Math.random() * 80,
                    speed: 0.2 + Math.random() * 0.3
                });
            }

            // Generate birds
            for (let i = 0; i < 10; i++) {
                birds.push({
                    x: Math.random() * totalLength,
                    y: 100 + Math.random() * 200,
                    wingPhase: Math.random() * Math.PI * 2,
                    speed: 1 + Math.random() * 2
                });
            }
        }

        function getTerrainY(x) {
            for (let i = 0; i < terrainPoints.length - 1; i++) {
                if (x >= terrainPoints[i].x && x <= terrainPoints[i + 1].x) {
                    const t = (x - terrainPoints[i].x) / (terrainPoints[i + 1].x - terrainPoints[i].x);
                    return terrainPoints[i].y + t * (terrainPoints[i + 1].y - terrainPoints[i].y);
                }
            }
            return canvas.height - 150;
        }

        function getTerrainAngle(x) {
            const y1 = getTerrainY(x - 15);
            const y2 = getTerrainY(x + 15);
            return Math.atan2(y1 - y2, 30);
        }

        // Drawing functions
        function drawSky() {
            const zone = getCurrentZone();
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, zone.skyTop);
            gradient.addColorStop(1, zone.skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sun
            const sunX = canvas.width - 100;
            const sunY = 80;
            const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 60);
            sunGradient.addColorStop(0, '#fff9c4');
            sunGradient.addColorStop(0.5, '#ffd93d');
            sunGradient.addColorStop(1, 'rgba(255, 217, 61, 0)');
            ctx.fillStyle = sunGradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
            ctx.fill();

            // Sun rays
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.3)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + Date.now() / 5000;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * 50, sunY + Math.sin(angle) * 50);
                ctx.lineTo(sunX + Math.cos(angle) * 90, sunY + Math.sin(angle) * 90);
                ctx.stroke();
            }
        }

        function drawClouds() {
            const time = Date.now() / 1000;
            clouds.forEach(cloud => {
                const cx = (cloud.x - cameraX * 0.1 + time * cloud.speed * 20) % (canvas.width + 200) - 100;
                const cy = cloud.y - cameraY * 0.05;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.ellipse(cx, cy, cloud.width * 0.5, cloud.width * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx - cloud.width * 0.3, cy + 5, cloud.width * 0.35, cloud.width * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx + cloud.width * 0.25, cy + 3, cloud.width * 0.3, cloud.width * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBackgroundMountains() {
            const zone = getCurrentZone();
            const layers = [
                { parallax: 0.15, alpha: 0.25, yOffset: 100 },
                { parallax: 0.25, alpha: 0.4, yOffset: 50 },
                { parallax: 0.4, alpha: 0.6, yOffset: 0 }
            ];

            layers.forEach((layer, li) => {
                backgroundMountains.filter(m => m.layer === li).forEach(mountain => {
                    const mx = mountain.x - cameraX * layer.parallax;
                    const screenX = ((mx % (canvas.width * 3)) + canvas.width * 3) % (canvas.width * 3) - canvas.width;
                    const my = canvas.height - mountain.height + layer.yOffset - cameraY * layer.parallax * 0.5;

                    ctx.fillStyle = `rgba(${hexToRgb(zone.groundColor)}, ${layer.alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(screenX - mountain.width / 2, canvas.height);
                    ctx.lineTo(screenX, my);
                    ctx.lineTo(screenX + mountain.width / 2, canvas.height);
                    ctx.closePath();
                    ctx.fill();

                    // Snow cap for high mountains
                    if (mountain.height > 250) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${layer.alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.moveTo(screenX - mountain.width * 0.15, my + mountain.height * 0.3);
                        ctx.lineTo(screenX, my);
                        ctx.lineTo(screenX + mountain.width * 0.15, my + mountain.height * 0.3);
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            });
        }

        function drawBirds() {
            const time = Date.now() / 1000;
            ctx.fillStyle = '#2d3436';
            birds.forEach(bird => {
                const bx = bird.x - cameraX * 0.3;
                const by = bird.y - cameraY * 0.2 + Math.sin(time * 2 + bird.wingPhase) * 10;
                const screenX = ((bx % (canvas.width * 2)) + canvas.width * 2) % (canvas.width * 2) - canvas.width * 0.5;

                if (screenX > -50 && screenX < canvas.width + 50) {
                    const wingY = Math.sin(time * 8 + bird.wingPhase) * 8;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 15, by + wingY);
                    ctx.quadraticCurveTo(screenX, by - 5, screenX + 15, by + wingY);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#2d3436';
                    ctx.stroke();
                }
            });
        }

        function drawTerrain() {
            const zone = getCurrentZone();

            // Main terrain
            ctx.beginPath();
            ctx.moveTo(-100, canvas.height + 100);

            for (let i = 0; i < terrainPoints.length; i++) {
                const px = terrainPoints[i].x - cameraX;
                const py = terrainPoints[i].y - cameraY;
                if (px > -300 && px < canvas.width + 300) {
                    if (i === 0 || terrainPoints[i - 1].x - cameraX <= -300) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
            }

            ctx.lineTo(canvas.width + 100, canvas.height + 100);
            ctx.lineTo(-100, canvas.height + 100);
            ctx.closePath();

            // Terrain gradient
            const terrainGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            terrainGradient.addColorStop(0, zone.grassColor);
            terrainGradient.addColorStop(0.3, zone.groundColor);
            terrainGradient.addColorStop(1, darkenColor(zone.groundColor, 30));
            ctx.fillStyle = terrainGradient;
            ctx.fill();

            // Terrain edge highlight
            ctx.strokeStyle = lightenColor(zone.grassColor, 20);
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < terrainPoints.length; i++) {
                const px = terrainPoints[i].x - cameraX;
                const py = terrainPoints[i].y - cameraY;
                if (px > -100 && px < canvas.width + 100) {
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();

            // Ground texture lines
            ctx.strokeStyle = darkenColor(zone.groundColor, 15);
            ctx.lineWidth = 1;
            for (let i = 0; i < terrainPoints.length - 1; i++) {
                const px = terrainPoints[i].x - cameraX;
                if (px > -50 && px < canvas.width + 50) {
                    const py = terrainPoints[i].y - cameraY;
                    for (let j = 1; j < 4; j++) {
                        ctx.beginPath();
                        ctx.moveTo(px, py + j * 25);
                        ctx.lineTo(px + 30, py + j * 25 + 5);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawSceneryBack() {
            const zone = getCurrentZone();
            sceneryItems.filter(s => s.layer === 'back').forEach(item => {
                const sx = item.x - cameraX * 0.8;
                const sy = getTerrainY(item.x) - cameraY - 20;

                if (sx > -100 && sx < canvas.width + 100) {
                    ctx.globalAlpha = 0.6;
                    ctx.font = `${40 * item.scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(item.type, sx, sy);
                    ctx.globalAlpha = 1;
                }
            });
        }

        function drawSceneryFront() {
            sceneryItems.filter(s => s.layer === 'front').forEach(item => {
                const sx = item.x - cameraX;
                const sy = getTerrainY(item.x) - cameraY - 20;

                if (sx > -100 && sx < canvas.width + 100) {
                    ctx.font = `${50 * item.scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(item.type, sx, sy);
                }
            });
        }

        function drawCollectibles() {
            const time = Date.now() / 1000;
            collectibles.forEach(item => {
                if (item.collected) return;

                const ix = item.x - cameraX;
                const iy = item.y - cameraY;
                if (ix > -50 && ix < canvas.width + 50) {
                    const bobY = Math.sin(time * 3 + item.bobOffset) * 8;
                    const scale = 1 + Math.sin(time * 4 + item.bobOffset) * 0.1;

                    ctx.save();
                    ctx.translate(ix, iy + bobY);
                    ctx.scale(scale, scale);

                    // Glow effect
                    const glowColor = item.type === 'star' ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 107, 107, 0.4)';
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 20;

                    ctx.font = `${Math.min(50, canvas.width * 0.1)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (item.type === 'star') {
                        ctx.fillText('‚≠ê', 0, 0);
                    } else {
                        ctx.fillText('‚õΩ', 0, 0);
                    }

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
        }

        function drawDustParticles() {
            ctx.globalAlpha = 0.6;
            dustParticles.forEach((p, i) => {
                p.x -= truckVelocityX * 0.3;
                p.y += p.vy;
                p.life--;
                p.vy -= 0.05;

                if (p.life <= 0) {
                    dustParticles.splice(i, 1);
                    return;
                }

                const alpha = p.life / p.maxLife;
                const zone = getCurrentZone();
                ctx.fillStyle = zone.groundColor;
                ctx.globalAlpha = alpha * 0.5;
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y - cameraY, p.size * (1 + (1 - alpha) * 2), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawBoostParticles() {
            boostParticles.forEach((p, i) => {
                p.x -= p.vx;
                p.y += p.vy;
                p.life--;

                if (p.life <= 0) {
                    boostParticles.splice(i, 1);
                    return;
                }

                const alpha = p.life / p.maxLife;
                const gradient = ctx.createRadialGradient(p.x - cameraX, p.y - cameraY, 0, p.x - cameraX, p.y - cameraY, p.size);
                gradient.addColorStop(0, `rgba(255, 150, 50, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(255, 100, 50, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y - cameraY, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawTruck() {
            const tx = truckX - cameraX;
            const ty = truckY - cameraY;

            ctx.save();
            ctx.translate(tx, ty);
            ctx.rotate(truckAngle);

            const truckWidth = 90;
            const truckHeight = 55;

            // Calculate suspension
            const targetFront = isInAir ? 5 : (truckVelocityY > 0 ? -8 : 3);
            const targetRear = isInAir ? -5 : (truckVelocityY > 0 ? 8 : -3);
            frontSuspension += (targetFront - frontSuspension) * 0.2;
            rearSuspension += (targetRear - rearSuspension) * 0.2;

            // Shadow
            if (!isInAir) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.ellipse(0, 30, 50, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Boost flames
            if (isBoosting && boostFuel > 0) {
                const flameTime = Date.now() / 50;
                for (let i = 0; i < 5; i++) {
                    const flameLen = 30 + Math.sin(flameTime + i) * 15;
                    const flameY = -20 + Math.sin(flameTime * 2 + i * 0.5) * 8;
                    const gradient = ctx.createLinearGradient(-truckWidth / 2 - 10, flameY, -truckWidth / 2 - 10 - flameLen, flameY);
                    gradient.addColorStop(0, 'rgba(255, 200, 50, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 50, 0.7)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(-truckWidth / 2 - 10, flameY - 12);
                    ctx.lineTo(-truckWidth / 2 - 10 - flameLen, flameY);
                    ctx.lineTo(-truckWidth / 2 - 10, flameY + 12);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Truck body with gradient
            const bodyGradient = ctx.createLinearGradient(0, -truckHeight, 0, 10);
            bodyGradient.addColorStop(0, lightenColor(currentColor, 15));
            bodyGradient.addColorStop(0.5, currentColor);
            bodyGradient.addColorStop(1, darkenColor(currentColor, 15));
            ctx.fillStyle = bodyGradient;

            // Main body
            ctx.beginPath();
            ctx.roundRect(-truckWidth / 2, -truckHeight + frontSuspension, truckWidth, truckHeight, 15);
            ctx.fill();

            // Body highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.roundRect(-truckWidth / 2 + 5, -truckHeight + 5 + frontSuspension, truckWidth - 10, 15, [10, 10, 0, 0]);
            ctx.fill();

            // Roll cage
            ctx.strokeStyle = darkenColor(currentColor, 30);
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-truckWidth / 2 + 15, -truckHeight + frontSuspension);
            ctx.lineTo(-truckWidth / 2 + 15, -truckHeight - 30 + frontSuspension);
            ctx.lineTo(truckWidth / 2 - 25, -truckHeight - 30 + frontSuspension);
            ctx.lineTo(truckWidth / 2 - 25, -truckHeight + frontSuspension);
            ctx.stroke();

            // Cabin
            const cabinGradient = ctx.createLinearGradient(0, -truckHeight - 30, 0, -truckHeight);
            cabinGradient.addColorStop(0, lightenColor(currentColor, 25));
            cabinGradient.addColorStop(1, lightenColor(currentColor, 10));
            ctx.fillStyle = cabinGradient;
            ctx.beginPath();
            ctx.roundRect(-truckWidth / 2 + 12, -truckHeight - 28 + frontSuspension, truckWidth - 34, 28, [12, 12, 0, 0]);
            ctx.fill();

            // Windows
            ctx.fillStyle = '#74b9ff';
            ctx.beginPath();
            ctx.roundRect(-truckWidth / 2 + 18, -truckHeight - 22 + frontSuspension, truckWidth - 46, 18, 6);
            ctx.fill();

            // Window reflections
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.roundRect(-truckWidth / 2 + 20, -truckHeight - 20 + frontSuspension, 18, 10, 4);
            ctx.fill();

            // Wheels with suspension
            const wheelRadius = 22;
            const leftWheelY = 12 + rearSuspension;
            const rightWheelY = 12 + frontSuspension;

            // Suspension arms
            ctx.strokeStyle = '#2d3436';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(-28, -5);
            ctx.lineTo(-28, leftWheelY - 5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(28, -5);
            ctx.lineTo(28, rightWheelY - 5);
            ctx.stroke();

            // Left wheel
            this.drawWheel(-28, leftWheelY, wheelRadius);

            // Right wheel
            this.drawWheel(28, rightWheelY, wheelRadius);

            // Headlights
            if (isInAir || isBoosting) {
                ctx.shadowColor = '#ffeaa7';
                ctx.shadowBlur = 20;
            }
            ctx.fillStyle = '#ffeaa7';
            ctx.beginPath();
            ctx.arc(truckWidth / 2 - 8, -18 + frontSuspension, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(truckWidth / 2 - 10, -20 + frontSuspension, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Tail lights
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-truckWidth / 2 + 8, -18 + rearSuspension, 6, 0, Math.PI * 2);
            ctx.fill();

            // Number plate / decal
            ctx.fillStyle = 'white';
            ctx.fillRect(-15, -25 + (frontSuspension + rearSuspension) / 2, 30, 18);
            ctx.fillStyle = '#2d3436';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('#1', 0, -12 + (frontSuspension + rearSuspension) / 2);

            // Hat
            if (currentHat) {
                const hatBounce = isInAir ? Math.sin(Date.now() / 80) * 6 : 0;
                const hatRotate = isInAir ? Math.sin(Date.now() / 120) * 0.25 : 0;
                ctx.save();
                ctx.rotate(hatRotate);
                ctx.font = '45px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentHat, -5, -truckHeight - 40 + frontSuspension + hatBounce);
                ctx.restore();
            }

            // Exhaust
            if (isPlaying || truckVelocityX > 1) {
                const puffCount = isBoosting ? 6 : 3;
                const time = Date.now() / 60;
                ctx.fillStyle = 'rgba(180, 180, 180, 0.5)';
                for (let i = 0; i < puffCount; i++) {
                    const px = -truckWidth / 2 - 18 - i * 14;
                    const py = -10 + rearSuspension + Math.sin(time + i) * 6;
                    const psize = 8 + i * 5;
                    ctx.beginPath();
                    ctx.arc(px, py, psize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        drawWheel = function(x, y, radius) {
            // Tire
            const tireGradient = ctx.createRadialGradient(x, y, radius - 8, x, y, radius);
            tireGradient.addColorStop(0, '#3d3d3d');
            tireGradient.addColorStop(1, '#1a1a1a');
            ctx.fillStyle = tireGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Tire treads
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 2;
            const wheelRotation = (truckX / 15) % (Math.PI * 2);
            for (let i = 0; i < 8; i++) {
                const angle = wheelRotation + (i * Math.PI / 4);
                ctx.beginPath();
                ctx.arc(x, y, radius - 2, angle - 0.15, angle + 0.15);
                ctx.stroke();
            }

            // Rim
            const rimGradient = ctx.createRadialGradient(x - 3, y - 3, 0, x, y, radius - 6);
            rimGradient.addColorStop(0, '#c0c0c0');
            rimGradient.addColorStop(0.5, '#808080');
            rimGradient.addColorStop(1, '#505050');
            ctx.fillStyle = rimGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius - 6, 0, Math.PI * 2);
            ctx.fill();

            // Rim spokes
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 3;
            for (let i = 0; i < 5; i++) {
                const angle = wheelRotation + (i * Math.PI * 2 / 5);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * (radius - 8), y + Math.sin(angle) * (radius - 8));
                ctx.stroke();
            }

            // Center cap
            ctx.fillStyle = '#707070';
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function hexToRgb(hex) {
            const num = parseInt(hex.replace('#', ''), 16);
            return `${(num >> 16)}, ${(num >> 8) & 0xFF}, ${num & 0xFF}`;
        }

        // Collision detection
        function checkCollisions() {
            collectibles.forEach(item => {
                if (item.collected) return;

                const dx = truckX - item.x;
                const dy = truckY - 30 - item.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 65) {
                    item.collected = true;

                    if (item.type === 'star') {
                        stars++;
                        trickScore += 50 * Math.max(1, comboCount);
                        document.getElementById('starCount').textContent = stars;
                        document.getElementById('trickScore').textContent = trickScore;
                        playSound('ding');
                        showCollectEffect(item.x - cameraX, item.y - cameraY, '‚≠ê +50');
                    } else {
                        boostFuel = Math.min(100, boostFuel + 30);
                        playSound('boost');
                        showCollectEffect(item.x - cameraX, item.y - cameraY, '‚õΩ +30%');
                    }

                    createSparkles(item.x - cameraX, item.y - cameraY);
                }
            });
        }

        function showCollectEffect(x, y, text) {
            const el = document.createElement('div');
            el.className = 'collect-text';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.getElementById('gameContainer').appendChild(el);
            setTimeout(() => el.remove(), 1200);
        }

        function createSparkles(x, y) {
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    sparkle.style.left = (x + (Math.random() - 0.5) * 80) + 'px';
                    sparkle.style.top = (y + (Math.random() - 0.5) * 80) + 'px';
                    document.getElementById('gameContainer').appendChild(sparkle);
                    setTimeout(() => sparkle.remove(), 600);
                }, i * 40);
            }
        }

        function showTrick(text, points) {
            const display = document.getElementById('trickDisplay');
            const el = document.createElement('div');
            el.className = 'trick-text';
            el.textContent = `${text} +${points}`;
            display.innerHTML = '';
            display.appendChild(el);
            setTimeout(() => el.remove(), 1000);

            trickScore += points * Math.max(1, comboCount);
            document.getElementById('trickScore').textContent = trickScore;
        }

        function updateCombo() {
            if (comboCount > 1) {
                document.getElementById('comboDisplay').classList.remove('hidden');
                document.getElementById('comboMultiplier').textContent = `x${comboCount}`;
            }

            comboTimer = 120;
        }

        // Unlock system
        function checkUnlocks() {
            const height = canvas.height - truckY;

            allColors.forEach(c => {
                if (height >= c.height && !unlockedColors.includes(c.color)) {
                    unlockedColors.push(c.color);
                    showUnlock('New Color!', c.color, c.name);
                    updateCustomizePanel();
                }
            });

            allHats.forEach(h => {
                if (height >= h.height && !unlockedHats.includes(h.emoji)) {
                    unlockedHats.push(h.emoji);
                    if (h.emoji) showUnlock('New Hat!', h.emoji, h.name);
                    updateCustomizePanel();
                }
            });
        }

        function showUnlock(title, item, name) {
            playSound('unlock');
            const notification = document.createElement('div');
            notification.className = 'unlock-notification';
            notification.innerHTML = `
                <h2>${title}</h2>
                <div class="unlock-item" style="${item.startsWith('#') ? `background: ${item}; width: 70px; height: 70px; border-radius: 50%; margin: 10px auto;` : ''}">${item.startsWith('#') ? '' : item}</div>
                <p>${name} Unlocked!</p>
            `;
            document.getElementById('gameContainer').appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }

        function updateCustomizePanel() {
            const colorOptions = document.getElementById('colorOptions');
            colorOptions.innerHTML = '';
            allColors.forEach(c => {
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (currentColor === c.color ? ' active' : '') + (!unlockedColors.includes(c.color) ? ' locked' : '');
                btn.style.background = c.color;
                btn.title = c.name;
                if (unlockedColors.includes(c.color)) {
                    btn.onclick = () => { currentColor = c.color; updateCustomizePanel(); };
                } else {
                    btn.textContent = 'üîí';
                    btn.style.fontSize = '0.7rem';
                }
                colorOptions.appendChild(btn);
            });

            const hatOptions = document.getElementById('hatOptions');
            hatOptions.innerHTML = '';
            allHats.forEach(h => {
                const btn = document.createElement('button');
                btn.className = 'hat-btn' + (currentHat === h.emoji ? ' active' : '') + (!unlockedHats.includes(h.emoji) ? ' locked' : '');
                btn.style.background = '#f8f9fa';
                btn.title = h.name;
                if (unlockedHats.includes(h.emoji)) {
                    btn.textContent = h.emoji || '‚ùå';
                    btn.onclick = () => { currentHat = h.emoji; updateCustomizePanel(); };
                } else {
                    btn.textContent = 'üîí';
                    btn.style.fontSize = '0.7rem';
                }
                hatOptions.appendChild(btn);
            });
        }

        function updateZoneIndicator() {
            const zone = getCurrentZone();
            const indicator = document.getElementById('zoneIndicator');
            indicator.innerHTML = `<span>${zone.icon}</span><span>${zone.name} Zone</span>`;
        }

        // Game loop
        let lastEngineSound = 0;

        function update() {
            const maxSpeed = isBoosting && boostFuel > 0 ? 14 : 10;
            const accel = isBoosting && boostFuel > 0 ? 0.6 : 0.35;

            if (isPlaying) {
                truckVelocityX = Math.min(truckVelocityX + accel, maxSpeed);

                if (Date.now() - lastEngineSound > 120) {
                    playSound('engine');
                    lastEngineSound = Date.now();
                }
            } else {
                truckVelocityX *= 0.97;
                if (truckVelocityX < 0.1) truckVelocityX = 0;
            }

            // Boost fuel consumption
            if (isBoosting && boostFuel > 0) {
                boostFuel -= 0.8;
                if (boostFuel <= 0) {
                    boostFuel = 0;
                    document.getElementById('boostButton').classList.add('empty');
                }

                // Boost particles
                if (Math.random() < 0.5) {
                    boostParticles.push({
                        x: truckX - 50,
                        y: truckY - 20 + (Math.random() - 0.5) * 30,
                        vx: 8 + Math.random() * 4,
                        vy: (Math.random() - 0.5) * 3,
                        size: 15 + Math.random() * 15,
                        life: 30,
                        maxLife: 30
                    });
                }
            }

            // Update boost UI
            document.getElementById('boostFill').style.height = boostFuel + '%';
            if (boostFuel > 0) {
                document.getElementById('boostButton').classList.remove('empty');
            }

            truckX += truckVelocityX;

            const groundY = getTerrainY(truckX);
            const targetAngle = getTerrainAngle(truckX);

            const wasInAir = isInAir;
            isInAir = truckY < groundY - 35;

            if (isInAir) {
                airTime++;
                truckVelocityY += 0.38;

                // Angular momentum in air
                truckAngularVelocity += targetAngle * 0.02;
                truckAngle += truckAngularVelocity;
                totalRotation += Math.abs(truckAngularVelocity);

                // Check for flips
                const flipCount = Math.floor(Math.abs(totalRotation) / (Math.PI * 2));
                if (flipCount > lastFlipCount) {
                    const direction = truckAngularVelocity > 0 ? 'BACKFLIP!' : 'FRONTFLIP!';
                    showTrick(direction, 200);
                    playSound('flip');
                    comboCount++;
                    updateCombo();
                    lastFlipCount = flipCount;
                }

            } else {
                // Landing
                if (wasInAir && airTime > 8) {
                    playSound('land');

                    // Successful trick landing
                    if (lastFlipCount > 0) {
                        const bonus = lastFlipCount * 100;
                        showTrick('LANDED!', bonus);
                        comboCount++;
                        updateCombo();
                    } else if (airTime > 25) {
                        showTrick('BIG AIR!', 50);
                        comboCount++;
                        updateCombo();
                    }

                    // Create dust on landing
                    for (let i = 0; i < 15; i++) {
                        dustParticles.push({
                            x: truckX + (Math.random() - 0.5) * 60,
                            y: groundY,
                            vy: -2 - Math.random() * 3,
                            size: 5 + Math.random() * 8,
                            life: 40 + Math.random() * 20,
                            maxLife: 60
                        });
                    }
                }

                airTime = 0;
                totalRotation = 0;
                lastFlipCount = 0;
                truckAngularVelocity = 0;

                truckY = groundY - 28;
                truckVelocityY = 0;

                // Launch from ramps
                if (targetAngle < -0.35 && truckVelocityX > 5) {
                    const launchPower = Math.abs(targetAngle) * truckVelocityX * 3.2;
                    truckVelocityY = -launchPower;
                    truckAngularVelocity = targetAngle * 0.08;
                    playSound('launch');

                    if (targetAngle < -0.6) {
                        truckVelocityY *= 1.25;
                    }
                }

                truckAngle += (targetAngle - truckAngle) * 0.25;

                // Dust while driving
                if (truckVelocityX > 3 && Math.random() < 0.3) {
                    dustParticles.push({
                        x: truckX - 30 + (Math.random() - 0.5) * 20,
                        y: groundY - 5,
                        vy: -1 - Math.random() * 2,
                        size: 4 + Math.random() * 5,
                        life: 25 + Math.random() * 15,
                        maxLife: 40
                    });
                }
            }

            truckY += truckVelocityY;
            truckY = Math.max(30, truckY);

            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    comboCount = 0;
                    document.getElementById('comboDisplay').classList.add('hidden');
                }
            }

            // Camera - improved vertical tracking
            const targetCameraX = truckX - canvas.width * 0.3;

            // Keep truck vertically centered in the middle portion of screen
            // Target: truck should appear at about 55% down the screen
            const targetScreenY = canvas.height * 0.55;
            const targetCameraY = truckY - targetScreenY;

            cameraX += (targetCameraX - cameraX) * 0.08;
            cameraY += (targetCameraY - cameraY) * 0.12;
            cameraX = Math.max(0, cameraX);

            // Update UI
            const speed = Math.round(truckVelocityX * 8);
            document.getElementById('speedValue').textContent = speed;
            document.getElementById('speedFill').style.width = Math.min(100, speed) + '%';

            const height = Math.round((canvas.height - truckY) / 5);
            document.getElementById('heightValue').textContent = height + 'm';
            document.getElementById('heightFill').style.height = Math.min(100, height / 30 * 100) + '%';

            checkCollisions();
            checkUnlocks();
            updateZoneIndicator();
        }

        function draw() {
            drawSky();
            drawClouds();
            drawBackgroundMountains();
            drawBirds();
            drawSceneryBack();
            drawTerrain();
            drawDustParticles();
            drawCollectibles();
            drawSceneryFront();
            drawBoostParticles();
            drawTruck();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Controls
        const playButton = document.getElementById('playButton');
        const boostButton = document.getElementById('boostButton');

        function startDriving() {
            initAudio();
            isPlaying = true;
            playButton.classList.add('pressed');
        }

        function stopDriving() {
            isPlaying = false;
            playButton.classList.remove('pressed');
        }

        function startBoost() {
            if (boostFuel > 0) {
                isBoosting = true;
                playSound('boost');
            }
        }

        function stopBoost() {
            isBoosting = false;
        }

        // Play button events
        playButton.addEventListener('mousedown', e => { e.preventDefault(); startDriving(); });
        playButton.addEventListener('mouseup', stopDriving);
        playButton.addEventListener('mouseleave', stopDriving);
        playButton.addEventListener('touchstart', e => { e.preventDefault(); startDriving(); });
        playButton.addEventListener('touchend', stopDriving);

        // Boost button events
        boostButton.addEventListener('mousedown', e => { e.preventDefault(); startBoost(); });
        boostButton.addEventListener('mouseup', stopBoost);
        boostButton.addEventListener('mouseleave', stopBoost);
        boostButton.addEventListener('touchstart', e => { e.preventDefault(); startBoost(); });
        boostButton.addEventListener('touchend', stopBoost);

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                if (!isPlaying) startDriving();
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.code === 'KeyX') {
                e.preventDefault();
                startBoost();
            }
        });

        document.addEventListener('keyup', e => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                stopDriving();
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.code === 'KeyX') {
                stopBoost();
            }
        });

        // Click anywhere
        document.addEventListener('mousedown', e => {
            if (e.target.closest('.home-btn, .sound-toggle, .customize-panel, .boost-button')) return;
            if (!isPlaying) startDriving();
        });

        document.addEventListener('mouseup', e => {
            if (e.target.closest('.home-btn, .sound-toggle, .customize-panel, .boost-button')) return;
            stopDriving();
        });

        // Initialize
        generateTerrain();
        updateCustomizePanel();
        truckY = getTerrainY(truckX) - 28;
        gameLoop();

        setTimeout(() => {
            document.getElementById('instruction').style.opacity = '0';
            setTimeout(() => document.getElementById('instruction').style.display = 'none', 500);
        }, 6000);
    </script>
</body>

</html>
