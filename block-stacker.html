<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Stacker - Fun Kids Game!</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@600;800&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(180deg, #1a0a2e 0%, #2d1b4e 50%, #1a0a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            text-align: center;
            position: relative;
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            color: #fff;
            font-size: clamp(2rem, 6vw, 3.5rem);
            text-shadow:
                0 0 20px rgba(255, 107, 107, 0.8),
                0 4px 0 #ff6b6b,
                0 8px 0 rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
            letter-spacing: 2px;
            animation: titleFloat 3s ease-in-out infinite;
        }

        @keyframes titleFloat {

            0%,
            100% {
                transform: translateY(0) rotate(-1deg);
            }

            50% {
                transform: translateY(-8px) rotate(1deg);
            }
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: clamp(10px, 3vw, 30px);
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .score-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 10px clamp(15px, 4vw, 30px);
            border-radius: 50px;
            color: white;
            font-size: clamp(0.9rem, 2.5vw, 1.3rem);
            font-weight: 800;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .score-item span {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.4));
        }

        #gameCanvas {
            border-radius: 20px;
            box-shadow:
                0 0 0 4px rgba(255, 255, 255, 0.1),
                0 10px 60px rgba(0, 0, 0, 0.5),
                inset 0 0 100px rgba(255, 255, 255, 0.05);
            cursor: pointer;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.8);
            margin-top: 15px;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            font-weight: 600;
        }

        .instructions kbd {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            padding: 6px 16px;
            border-radius: 10px;
            margin: 0 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 3px 0 rgba(0, 0, 0, 0.3);
        }

        .overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #ffffff 0%, #f8f9ff 100%);
            padding: clamp(25px, 5vw, 50px) clamp(30px, 6vw, 70px);
            border-radius: 30px;
            text-align: center;
            box-shadow:
                0 25px 80px rgba(0, 0, 0, 0.4),
                0 0 0 4px rgba(255, 255, 255, 0.3),
                inset 0 2px 0 white;
            z-index: 100;
            animation: screenPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes screenPop {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive;
            color: #2d1b4e;
            font-size: clamp(1.8rem, 5vw, 2.8rem);
            margin-bottom: 15px;
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
        }

        .overlay-screen p {
            color: #666;
            font-size: clamp(0.9rem, 2.5vw, 1.15rem);
            margin-bottom: 20px;
            line-height: 1.5;
            font-weight: 600;
        }

        .final-score {
            font-family: 'Fredoka One', cursive;
            font-size: clamp(2.5rem, 8vw, 4rem);
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 15px 0;
            animation: scorePulse 1s ease-in-out infinite;
        }

        @keyframes scorePulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .btn {
            background: linear-gradient(180deg, #ff6b6b 0%, #e74c3c 100%);
            color: white;
            border: none;
            padding: clamp(12px, 3vw, 18px) clamp(30px, 8vw, 50px);
            font-size: clamp(1.2rem, 3.5vw, 1.6rem);
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow:
                0 6px 0 #c0392b,
                0 10px 25px rgba(255, 107, 107, 0.4);
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow:
                0 9px 0 #c0392b,
                0 15px 35px rgba(255, 107, 107, 0.5);
        }

        .btn:active {
            transform: translateY(3px);
            box-shadow:
                0 3px 0 #c0392b,
                0 6px 15px rgba(255, 107, 107, 0.4);
        }

        .stars {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: -1;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.2;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.3);
            }
        }

        .combo-text {
            position: absolute;
            font-family: 'Fredoka One', cursive;
            font-size: clamp(1.5rem, 4vw, 2.2rem);
            color: #ffd700;
            text-shadow:
                0 0 20px rgba(255, 215, 0, 0.8),
                2px 2px 4px rgba(0, 0, 0, 0.4);
            pointer-events: none;
            animation: comboFloat 1.2s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes comboFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(0.5) rotate(-5deg);
            }

            30% {
                transform: translateY(-20px) scale(1.2) rotate(5deg);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1) rotate(0deg);
            }
        }

        .perfect-text {
            color: #00ff88 !important;
            text-shadow:
                0 0 30px rgba(0, 255, 136, 0.9),
                2px 2px 4px rgba(0, 0, 0, 0.4) !important;
        }

        .hidden {
            display: none !important;
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 200;
            backdrop-filter: blur(10px);
            transition: transform 0.2s;
        }

        .sound-toggle:hover {
            transform: scale(1.1);
        }

        .sound-toggle.muted {
            opacity: 0.5;
        }

        /* High score badge */
        .new-best {
            position: absolute;
            top: -15px;
            right: -15px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: #2d1b4e;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 800;
            animation: badgeBounce 0.5s ease infinite;
            box-shadow: 0 3px 15px rgba(255, 215, 0, 0.5);
        }

        @keyframes badgeBounce {

            0%,
            100% {
                transform: rotate(-10deg) scale(1);
            }

            50% {
                transform: rotate(10deg) scale(1.1);
            }
        }

        /* Mobile touch button */
        .touch-zone {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: auto;
            padding: 15px;
            background: linear-gradient(180deg, transparent, rgba(255, 107, 107, 0.2));
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: none;
        }

        .touch-btn {
            background: linear-gradient(180deg, #ff6b6b, #e74c3c);
            color: white;
            border: none;
            padding: clamp(15px, 4vw, 20px) clamp(40px, 10vw, 60px);
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            font-family: 'Fredoka One', cursive;
            border-radius: 60px;
            box-shadow: 0 8px 0 #c0392b, 0 15px 40px rgba(0, 0, 0, 0.4);
            pointer-events: all;
        }

        .touch-btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #c0392b, 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        @media (hover: none) and (pointer: coarse) {
            .touch-zone {
                display: flex;
            }

            .instructions {
                display: none;
            }

            #gameCanvas {
                max-height: calc(100vh - 280px);
            }

            .game-container {
                padding-bottom: 100px;
            }
        }

        .home-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 18px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 700;
            text-decoration: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .home-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <a href="index.html" class="home-btn">üè† Home</a>
    <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">üîä</button>

    <div class="stars" id="stars"></div>

    <div class="game-container">
        <h1>Block Stacker!</h1>

        <div class="score-board">
            <div class="score-item">Score: <span id="score">0</span></div>
            <div class="score-item">Level: <span id="level">1</span></div>
            <div class="score-item">Combo: <span id="combo">0</span>x</div>
        </div>

        <canvas id="gameCanvas" width="400" height="500"></canvas>

        <div class="instructions">
            Press <kbd>SPACE</kbd> or <kbd>TAP</kbd> to drop the block!
        </div>

        <div id="startScreen" class="overlay-screen">
            <h2>Ready to Stack?</h2>
            <p>
                Stack the blocks as high as you can!<br>
                Perfect drops give bonus points!
            </p>
            <button class="btn" onclick="startGame()">Let's Play!</button>
        </div>

        <div id="gameOverScreen" class="overlay-screen hidden">
            <h2>Game Over!</h2>
            <div class="final-score" id="finalScore">0</div>
            <div id="newBestBadge" class="new-best hidden">NEW BEST!</div>
            <p id="gameOverText">Great job stacking!</p>
            <button class="btn" onclick="startGame()">Play Again!</button>
        </div>
    </div>

    <div class="touch-zone" id="touchZone">
        <button class="touch-btn" id="touchBtn">TAP TO DROP!</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Audio context for sound effects
        let audioCtx = null;
        let soundEnabled = true;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'drop':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'perfect':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'levelup':
                    const osc1 = audioCtx.createOscillator();
                    const gain1 = audioCtx.createGain();
                    osc1.connect(gain1);
                    gain1.connect(audioCtx.destination);
                    osc1.type = 'sine';
                    osc1.frequency.setValueAtTime(440, audioCtx.currentTime);
                    osc1.frequency.setValueAtTime(554, audioCtx.currentTime + 0.1);
                    osc1.frequency.setValueAtTime(659, audioCtx.currentTime + 0.2);
                    osc1.frequency.setValueAtTime(880, audioCtx.currentTime + 0.3);
                    gain1.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc1.start();
                    osc1.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'gameover':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundToggle');
            btn.textContent = soundEnabled ? 'üîä' : 'üîá';
            btn.classList.toggle('muted', !soundEnabled);
        }

        // Game state
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let combo = 0;
        let blocks = [];
        let currentBlock = null;
        let particles = [];
        let bestScore = parseInt(localStorage.getItem('blockStackerBest')) || 0;

        // Block colors - vibrant candy palette
        const colors = [
            '#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff',
            '#9b59b6', '#ff8c42', '#00d2d3', '#ff6b9d',
            '#a8e6cf', '#fdcb6e', '#e17055', '#00cec9'
        ];

        // Create background stars
        function createStars() {
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = '';
            for (let i = 0; i < 60; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 4 + 2) + 'px';
                star.style.animationDelay = Math.random() * 2 + 's';
                star.style.animationDuration = (Math.random() * 2 + 1.5) + 's';
                starsContainer.appendChild(star);
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 10 + 5;
                this.speedX = (Math.random() - 0.5) * 12;
                this.speedY = (Math.random() - 0.5) * 12 - 6;
                this.gravity = 0.4;
                this.life = 1;
                this.decay = Math.random() * 0.02 + 0.015;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 15;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
                this.rotation += this.rotationSpeed;
                this.speedX *= 0.99;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.fillStyle = this.color;

                // Draw as rounded square
                const r = 3;
                ctx.beginPath();
                ctx.roundRect(-this.size / 2, -this.size / 2, this.size, this.size, r);
                ctx.fill();

                ctx.restore();
            }
        }

        // Block class
        class Block {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.targetY = y;
                this.velocity = 0;
                this.settled = false;
                this.wobble = 0;
                this.wobbleSpeed = 0;
                this.glow = 0;
            }

            draw() {
                ctx.save();

                // Wobble effect
                if (this.wobble !== 0) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height);
                    ctx.rotate(this.wobble * Math.PI / 180);
                    ctx.translate(-(this.x + this.width / 2), -(this.y + this.height));
                }

                // Glow effect
                if (this.glow > 0) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 30 * this.glow;
                }

                // Main block with gradient
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                gradient.addColorStop(0, this.lightenColor(this.color, 30));
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, this.darkenColor(this.color, 20));

                ctx.fillStyle = gradient;
                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetY = 6;

                // Rounded rectangle
                const radius = 10;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, radius);
                ctx.fill();

                // Top shine
                ctx.shadowColor = 'transparent';
                const shineGradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height * 0.5);
                shineGradient.addColorStop(0, 'rgba(255,255,255,0.5)');
                shineGradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = shineGradient;
                ctx.beginPath();
                ctx.roundRect(this.x + 4, this.y + 4, this.width - 8, this.height * 0.4, [radius - 2, radius - 2, 0, 0]);
                ctx.fill();

                // Edge highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2, radius);
                ctx.stroke();

                ctx.restore();
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }

            update() {
                if (!this.settled) {
                    this.velocity += 0.9;
                    this.y += this.velocity;

                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.velocity = 0;
                        this.settled = true;
                        this.wobble = (Math.random() - 0.5) * 12;
                        this.wobbleSpeed = -this.wobble * 0.25;
                        this.glow = 1;
                    }
                }

                // Glow fade
                if (this.glow > 0) {
                    this.glow -= 0.03;
                }

                // Wobble animation
                if (this.wobble !== 0) {
                    this.wobble += this.wobbleSpeed;
                    this.wobbleSpeed += -this.wobble * 0.08;
                    this.wobbleSpeed *= 0.92;
                    if (Math.abs(this.wobble) < 0.1 && Math.abs(this.wobbleSpeed) < 0.1) {
                        this.wobble = 0;
                        this.wobbleSpeed = 0;
                    }
                }
            }
        }

        // Moving block class
        class MovingBlock extends Block {
            constructor(width, height, color, speed) {
                super(0, 50, width, height, color);
                this.speed = speed;
                this.direction = 1;
                this.settled = true;
            }

            update() {
                this.x += this.speed * this.direction;

                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                    this.direction = -1;
                } else if (this.x < 0) {
                    this.x = 0;
                    this.direction = 1;
                }
            }
        }

        function createParticles(x, y, color, count = 25) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function showFloatingText(text, x, y, isPerfect = false) {
            const textEl = document.createElement('div');
            textEl.className = 'combo-text' + (isPerfect ? ' perfect-text' : '');
            textEl.textContent = text;
            textEl.style.left = (canvas.offsetLeft + x) + 'px';
            textEl.style.top = (canvas.offsetTop + y) + 'px';
            document.querySelector('.game-container').appendChild(textEl);

            setTimeout(() => textEl.remove(), 1200);
        }

        function spawnNewBlock() {
            const lastBlock = blocks[blocks.length - 1];
            const baseWidth = lastBlock ? lastBlock.width : 120;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const speed = 3 + level * 0.6;

            currentBlock = new MovingBlock(baseWidth, 32, color, speed);
        }

        function dropBlock() {
            if (!currentBlock || !gameRunning) return;

            initAudio();

            const lastBlock = blocks[blocks.length - 1];
            let overlap, newX, newWidth;

            if (lastBlock) {
                const currentRight = currentBlock.x + currentBlock.width;
                const lastRight = lastBlock.x + lastBlock.width;

                const overlapLeft = Math.max(currentBlock.x, lastBlock.x);
                const overlapRight = Math.min(currentRight, lastRight);
                overlap = overlapRight - overlapLeft;

                if (overlap <= 0) {
                    gameOver();
                    return;
                }

                newX = overlapLeft;
                newWidth = overlap;
            } else {
                newX = currentBlock.x;
                newWidth = currentBlock.width;
                overlap = newWidth;
            }

            // Calculate target Y based on previous block's position
            const targetY = lastBlock ? lastBlock.targetY - 34 : canvas.height - 45;

            // Create the new settled block
            const newBlock = new Block(
                newX,
                currentBlock.y,
                newWidth,
                32,
                currentBlock.color
            );
            newBlock.targetY = targetY;
            newBlock.settled = false;
            blocks.push(newBlock);

            // Calculate score
            const perfectThreshold = 6;
            const isPerfect = lastBlock && Math.abs(currentBlock.x - lastBlock.x) < perfectThreshold;

            if (isPerfect) {
                combo++;
                score += 100 * combo;
                showFloatingText('PERFECT! +' + (100 * combo), newX + newWidth / 2, targetY - 60, true);
                createParticles(newX + newWidth / 2, targetY, '#00ff88', 40);
                playSound('perfect');
            } else {
                if (combo > 2) {
                    showFloatingText('Combo ended!', newX + newWidth / 2, targetY - 60);
                }
                combo = Math.max(0, combo - 1);
                score += 10 + Math.floor(overlap / 2);
                createParticles(newX + newWidth / 2, targetY, currentBlock.color, 20);
                playSound('drop');
            }

            // Level up every 5 blocks
            if (blocks.length % 5 === 0) {
                level++;
                showFloatingText('LEVEL ' + level + '!', canvas.width / 2, 150, true);
                playSound('levelup');
            }

            updateUI();

            // Check if tower is getting too high - scroll down
            if (targetY < 150) {
                blocks.forEach(b => {
                    b.y += 60;
                    b.targetY += 60;
                });
            }

            spawnNewBlock();
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('combo').textContent = combo;
        }

        function gameOver() {
            gameRunning = false;
            playSound('gameover');

            document.getElementById('finalScore').textContent = score;

            const isNewBest = score > bestScore;
            if (isNewBest) {
                bestScore = score;
                localStorage.setItem('blockStackerBest', bestScore);
                document.getElementById('newBestBadge').classList.remove('hidden');
                document.getElementById('gameOverText').textContent = 'New High Score!';
            } else {
                document.getElementById('newBestBadge').classList.add('hidden');
                document.getElementById('gameOverText').textContent = `Best: ${bestScore}`;
            }

            document.getElementById('gameOverScreen').classList.remove('hidden');

            // Explosion effect
            blocks.forEach(block => {
                createParticles(
                    block.x + block.width / 2,
                    block.y + block.height / 2,
                    block.color,
                    12
                );
            });
        }

        function startGame() {
            initAudio();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Reset game state
            score = 0;
            level = 1;
            combo = 0;
            blocks = [];
            particles = [];
            currentBlock = null;

            updateUI();

            // Create base block
            const baseBlock = new Block(
                canvas.width / 2 - 60,
                canvas.height - 45,
                120,
                32,
                colors[0]
            );
            baseBlock.settled = true;
            blocks.push(baseBlock);

            spawnNewBlock();
            gameRunning = true;
        }

        function drawBackground() {
            // Deep space gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a0a2e');
            gradient.addColorStop(0.5, '#2d1b4e');
            gradient.addColorStop(1, '#1a0a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ground platform
            const platformGradient = ctx.createLinearGradient(0, canvas.height - 40, 0, canvas.height);
            platformGradient.addColorStop(0, '#4a2c7a');
            platformGradient.addColorStop(1, '#2d1b4e');
            ctx.fillStyle = platformGradient;
            ctx.beginPath();
            ctx.roundRect(10, canvas.height - 40, canvas.width - 20, 35, [15, 15, 0, 0]);
            ctx.fill();

            // Platform highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, canvas.height - 40);
            ctx.lineTo(canvas.width - 20, canvas.height - 40);
            ctx.stroke();

            // Decorative circles
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            ctx.beginPath();
            ctx.arc(50, canvas.height - 100, 150, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(canvas.width - 30, 100, 100, 0, Math.PI * 2);
            ctx.fill();
        }

        function gameLoop() {
            // Clear and draw background
            drawBackground();

            // Update and draw particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Update and draw blocks
            blocks.forEach(block => {
                block.update();
                block.draw();
            });

            // Update and draw current block
            if (currentBlock && gameRunning) {
                currentBlock.update();
                currentBlock.draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                dropBlock();
            }
        });

        canvas.addEventListener('click', dropBlock);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            dropBlock();
        });

        // Touch button
        document.getElementById('touchBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            dropBlock();
        });
        document.getElementById('touchBtn').addEventListener('click', dropBlock);

        // Initialize
        createStars();
        gameLoop();
    </script>
</body>

</html>